/**
 * @module
 */

// Neverthrow
import type { ResultAsync } from "neverthrow";
import { okAsync as nOkAsync, errAsync as nErrAsync } from "neverthrow";
import { fmtNeverthrowErr } from "../tests/util/fmtErrTest.ts";

import { access, mkdir, writeFile } from "node:fs/promises";
import path from "node:path";

// Utility
import { featureFlagsBuilderRaw } from "../../AeroSandbox/featureFlagsBuilder.ts";
import getInterfaceKV from "./util/getInterfaceKV.ts";
import validateTS from "./util/validateTS.ts";

/**
 * Inits the feature flags in the global scope for TS files, so that they won't error in your IDE 
 * @param featureFlagsPath The TS types file to output to. By default it is the feature flags from aero.
 * @param createDefaultFeatureFlags The method to create the default feature flags from. By default it is the feature flags from aero.
 * @returns The result of the operation wrapped in a `Result` from *Neverthrow* for better error handling
 */
export default async function initGlobalsTs(
	featureFlagsPath = "../../aeroSW/types/featureFlags.ts",
	featureFlagsInterfaceName = "FeatureFlagsRspack"
): Promise<ResultAsync<void, Error>> {
	const relFeatureFlagsPath = path.resolve(__dirname, featureFlagsPath);
	const interfaceKVRawRes = await getInterfaceKV(relFeatureFlagsPath, featureFlagsInterfaceName);
	if (interfaceKVRawRes.isErr())
		return fmtNeverthrowErr("Failed to get the keys of the feature flags interface", interfaceKVRawRes.error);
	/** The KV of the feature flags interface, but in camel case */
	const interfaceKVRaw = interfaceKVRawRes.value;
	// @ts-ignore
	const interfaceKV = featureFlagsBuilderRaw(interfaceKVRaw);

	const lines: string[] = [
		// We don't need to export anything
		"export { };", "", "declare global {"];
	for (const [featureFlag, type] of Object.entries(interfaceKV))
		lines.push(`\tconst ${featureFlag}: ${type};`);
	lines.push("}");

	const outputCode = lines.join("\n");
	// Parity check the final TS output before writing it
	const diagnosticErrors = await validateTS(outputCode);
	if (diagnosticErrors.length > 0)
		fmtNeverthrowErr("Parity check failed: the final TS output failed to validate, so globals.d.ts will not be created", diagnosticErrors.join("\n\t"));

	const dirsLeading = path.dirname(relFeatureFlagsPath);
	try {
		await access(dirsLeading);
	} catch (_err) {
		await mkdir(dirsLeading, {
			recursive: true
		})
	}

	try {
		await writeFile(
			relFeatureFlagsPath,
			`/** Autogenerated by \`initGlobalsTs.ts\` */\n${}`,
			{
				flag: "w",
			},
		);
	} catch (err) {
		return fmtNeverthrowErr("Failed to write the feature flags to the globals TS types file", err);
	}

	return nOkAsync(undefined);
}

/**
 * Detect if the script is being ran as a CLI script and not as a module
 */
const isCLI =
	// For Deno
	// @ts-ignore: This is a Deno-only feature
	"Deno" in globalThis ? import.meta.main :
		// For Node (this does the same thing functinally as the above)
		// @ts-ignore
		import.meta && import.meta.url === `file://${process.argv[1]}`;
if (isCLI) {
	(async () => {
		const initGlobalsTsRes = await initGlobalsTs();
		if (initGlobalsTsRes.isErr()) {
			throw initGlobalsTsRes.error;
		}
	})();
}
